from fastapi import FastAPI, HTTPException, Depends, WebSocket, WebSocketDisconnect
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import psycopg2
from psycopg2.extras import RealDictCursor
import redis.asyncio as redis
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter
import jwt
from datetime import datetime, timedelta
import os
import json
import subprocess
import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from cryptography.fernet import Fernet
import base64
import hashlib
import aiohttp
import random

# Configuration
class Config:
    def __init__(self):
        self.NODE_ID = os.getenv("NODE_ID", "node1")
        self.DATABASE_URL = os.getenv("DATABASE_URL", "dbname=novashell user=postgres password=password host=localhost")
        self.REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
        self.JWT_SECRET = os.getenv("JWT_SECRET", "supersecretkey")
        self.AI_API_URL = os.getenv("AI_API_URL", "http://localhost:11434/api/generate")

config = Config()

# Database Connection
def get_db_connection():
    return psycopg2.connect(config.DATABASE_URL, cursor_factory=RealDictCursor)

# Initialize Database Tables
def init_db():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            node_id VARCHAR PRIMARY KEY,
            password VARCHAR NOT NULL
        );
        CREATE TABLE IF NOT EXISTS nodes (
            node_id VARCHAR PRIMARY KEY,
            public_key VARCHAR,
            status VARCHAR,
            last_seen TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS vaults (
            label VARCHAR PRIMARY KEY,
            data TEXT,
            encrypted_data TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS messages (
            id SERIAL PRIMARY KEY,
            sender VARCHAR,
            recipient VARCHAR,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS tasks (
            task_id VARCHAR PRIMARY KEY,
            command VARCHAR,
            status VARCHAR,
            started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS schedules (
            id SERIAL PRIMARY KEY,
            cron VARCHAR,
            task VARCHAR,
            last_run TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS identities (
            address VARCHAR PRIMARY KEY,
            node_id VARCHAR,
            flame_points INTEGER DEFAULT 0
        );
    """)
    conn.commit()
    cursor.close()
    conn.close()

init_db()

# FastAPI App
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Redis Initialization
@app.on_event("startup")
async def startup():
    redis_client = await redis.from_url(config.REDIS_URL)
    await FastAPILimiter.init(redis_client)
    scheduler = AsyncIOScheduler()
    scheduler.start()

# Authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class User(BaseModel):
    node_id: str
    password: str

def create_token(node_id: str):
    payload = {"sub": node_id, "exp": datetime.utcnow() + timedelta(hours=24)}
    return jwt.encode(payload, config.JWT_SECRET, algorithm="HS256")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, config.JWT_SECRET, algorithms=["HS256"])
        node_id = payload.get("sub")
        if not node_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        return node_id
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT password FROM users WHERE node_id = %s", (form_data.username,))
    user = cursor.fetchone()
    cursor.close()
    conn.close()
    if not user or user["password"] != form_data.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_token(form_data.username)
    return {"access_token": token, "token_type": "bearer"}

# Status Endpoints
@app.get("/status", dependencies=[Depends(get_current_user), Depends(RateLimiter(times=5, seconds=60))])
async def get_status():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT node_id, status, last_seen FROM nodes")
    nodes = cursor.fetchall()
    cursor.close()
    conn.close()
    return {"nodes": nodes}

# AI Interaction
class AIPrompt(BaseModel):
    prompt: str

@app.post("/api/brain/ask")
async def ask_ai(prompt: AIPrompt, node_id: str = Depends(get_current_user)):
    async with aiohttp.ClientSession() as session:
        payload = {"model": "llama3", "prompt": prompt.prompt}
        async with session.post(config.AI_API_URL, json=payload) as resp:
            if resp.status == 200:
                result = await resp.json()
                return {"response": result.get("response", "No response")}
            raise HTTPException(status_code=500, detail="AI service unavailable")

# Quantum Encryption (Mock Implementation)
key = Fernet.generate_key()
cipher = Fernet(key)

@app.post("/api/quantum/encrypt")
async def encrypt_data(label: str, data: str, node_id: str = Depends(get_current_user)):
    encrypted_data = cipher.encrypt(data.encode()).decode()
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO vaults (label, data, encrypted_data) VALUES (%s, %s, %s) ON CONFLICT (label) DO UPDATE SET data = %s, encrypted_data = %s",
                   (label, data, encrypted_data, data, encrypted_data))
    conn.commit()
    cursor.close()
    conn.close()
    return {"label": label, "encrypted_data": encrypted_data}

@app.post("/api/quantum/decrypt")
async def decrypt_data(label: str, node_id: str = Depends(get_current_user)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT encrypted_data FROM vaults WHERE label = %s", (label,))
    result = cursor.fetchone()
    cursor.close()
    conn.close()
    if not result:
        raise HTTPException(status_code=404, detail="Vault not found")
    decrypted_data = cipher.decrypt(result["encrypted_data"].encode()).decode()
    return {"data": decrypted_data}

# Vault Sharing
@app.post("/api/vault/share")
async def share_vault(label: str, recipient_node_id: str, node_id: str = Depends(get_current_user)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT encrypted_data FROM vaults WHERE label = %s", (label,))
    result = cursor.fetchone()
    if not result:
        raise HTTPException(status_code=404, detail="Vault not found")
    # In a real system, encrypt for recipient's public key; here, we just copy
    cursor.execute("INSERT INTO vaults (label, encrypted_data) VALUES (%s || '-' || %s, %s) ON CONFLICT DO NOTHING",
                   (label, recipient_node_id, result["encrypted_data"]))
    conn.commit()
    cursor.close()
    conn.close()
    return {"message": f"Vault shared with {recipient_node_id}"}

# Messaging
class Message(BaseModel):
    recipient: str
    message: str

@app.post("/api/message/send")
async def send_message(msg: Message, node_id: str = Depends(get_current_user)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO messages (sender, recipient, message) VALUES (%s, %s, %s)",
                   (node_id, msg.recipient, msg.message))
    conn.commit()
    cursor.close()
    conn.close()
    return {"message": "Message sent"}

# Bot Deployment (Mock)
@app.post("/api/deploy/{bot_type}")
async def deploy_bot(bot_type: str, node_id: str = Depends(get_current_user)):
    task_id = f"{bot_type}-{datetime.utcnow().isoformat()}"
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO tasks (task_id, command, status) VALUES (%s, %s, %s)",
                   (task_id, f"deploy {bot_type}", "queued"))
    conn.commit()
    cursor.close()
    conn.close()
    return {"task_id": task_id}

# Blockchain Identity
@app.post("/api/blockchain/register")
async def register_identity(address: str, node_id: str = Depends(get_current_user)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO identities (address, node_id) VALUES (%s, %s) ON CONFLICT DO NOTHING",
                   (address, node_id))
    conn.commit()
    cursor.close()
    conn.close()
    return {"message": "Identity registered"}

# Command Execution
@app.post("/execute")
async def execute_command(command: str, node_id: str = Depends(get_current_user)):
    task_id = f"cmd-{datetime.utcnow().isoformat()}"
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO tasks (task_id, command, status) VALUES (%s, %s, %s)",
                   (task_id, command, "queued"))
    conn.commit()
    cursor.close()
    conn.close()
    return {"task_id": task_id}

# Task Scheduling
class Schedule(BaseModel):
    cron: str
    task: str

@app.post("/api/schedule")
async def schedule_task(schedule: Schedule, node_id: str = Depends(get_current_user)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT INTO schedules (cron, task) VALUES (%s, %s)", (schedule.cron, schedule.task))
    conn.commit()
    cursor.close()
    conn.close()
    return {"message": "Task scheduled"}

# WebSocket for Real-Time Status
@app.websocket("/ws/status")
async def websocket_status(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT node_id, status, last_seen FROM nodes")
            nodes = cursor.fetchall()
            cursor.close()
            conn.close()
            await websocket.send_json({"nodes": nodes})
            await asyncio.sleep(5)
    except WebSocketDisconnect:
        pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)